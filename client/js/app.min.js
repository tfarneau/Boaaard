var app = angular.module('App', [

    // Dependencies
    'ngRoute',
    'LocalStorageModule',
    'youtube-embed',
    'perfect_scrollbar',
    'gridster',

    // Views
    'boViewHome',
    'boViewSearch',
    'boViewCreate',
    'boViewBoard',

    // Components
    'boApi',
    'boSocket'
    // 'base_Component2',
    // 'base_Component3'
])

// App config
.config(['$routeProvider', 'localStorageServiceProvider', '$httpProvider', function($routeProvider, localStorageServiceProvider, $httpProvider) {
    
    // Local storage prefixer
    localStorageServiceProvider.setPrefix('_bo');

    // Cross domain authorization
    $httpProvider.defaults.useXDomain = true;
    delete $httpProvider.defaults.headers.common['X-Requested-With'];

    // Routes list
    $routeProvider
        // Home
        .when('/', {
            templateUrl: 'views/home/home.html',
            controller: 'HomeCtrl'
        })
        // Search
        .when('/search/:q?', {
            templateUrl: 'views/search/search.html',
            controller: 'SearchCtrl'
        })
        // Create board
        .when('/create', {
            templateUrl: 'views/create/create.html',
            controller: 'CreateCtrl'
        })
        // Create board with extension
        .when('/create/:url?', {
            templateUrl: 'views/create/create.html',
            controller: 'CreateCtrl'
        })
        // Board
        .when('/board/:slug', {
            templateUrl: 'views/board/board.html',
            controller: 'BoardCtrl'
        })
        .otherwise({redirectTo:'/'});

}])

// Main controller
.controller('AppCtrl', ['$scope', '$rootScope', 'localStorageService', function($scope, $rootScope, localStorageService) {
    $rootScope.title = "Boaaard";
}])

// App run
.run(['$route', '$rootScope', '$location', 'Socket', function($route, $rootScope, $location, Socket) {

    var history = [];

    // History push
    $rootScope.$on('$routeChangeSuccess', function() {
        history.push($location.$$path);
    });

    // Previous page method
    $rootScope.back = function (reload) {
        var prevUrl = history.length > 1 ? history.splice(-2)[0] : "/";
        $location.path(prevUrl, reload);
    };

    var original = $location.path;
    $location.path = function (path, reload) {
        if (reload === false) {
            var lastRoute = $route.current;
            var un = $rootScope.$on('$locationChangeSuccess', function () {
                $route.current = lastRoute;
                un();
            });
        }
        return original.apply($location, [path]);
    };
}]);

// Global API variables
// 
var SERVER_URL = "http://hetic.192.168.0.11.xip.io:3000";
// var SERVER_URL = "http://10.30.2.64:3000";
// var SERVER_URL = "http://10.30.2.143:3000";
var API_URL = "/api/";
angular
	.module('boApi', []);
angular
	.module('boApi')
	.factory('Api', ['$http', 'Find', function($http, Find){				
		return {
			Video : {
				// Validate url video
				validate : function(url){

					// Sanitize id video
					var id_video = url.split('v=')[1].substring(0, 11);

					return $http.get(SERVER_URL+API_URL+'validate_youtube/'+id_video);
				}
			},
			Board : {
				// Boards list
				list : function(){
					return $http.get(SERVER_URL+API_URL+"boards");
				},
				// Get one board by slug
				get : function(slug){
					return $http.get(SERVER_URL+API_URL+"boards/" + slug);
				},
				// Post a new board
				post : function(board){

					return $http({
						headers: {'Content-Type': 'application/json'}, 
						url: SERVER_URL+API_URL+"boards", 
						method: "POST", 
						data: JSON.stringify(board)
					});
		    	}
		    },
			Block : {
				// Get block
				get : function(type,req,findtype){
					if(findtype){
						type = Find.type(type,true);
					}
					return $http.get(SERVER_URL+API_URL+"block/"+type+"/"+req);
			    }
			}
		}
	}])
app.directive('block', ['Find', function(Find) {
	function link(scope, element, attrs) {
		element.addClass(Find.type(scope.block.type,false));
	}
	return {
		link: link,
		restrict: 'A'
	};
}]);
angular
	.module('boSocket', []);
angular
    .module('boSocket')
    .factory('Socket', ['$rootScope', function($rootScope){
        var socket = io.connect(SERVER_URL);
        return {
            // On event
            on: function (eventName, data, callback) {
                socket.on(eventName, data, function () {  
                    $rootScope.$apply(function () {
                        callback.apply(socket, arguments);
                    });
                });
            },
            // Emit event
            emit: function (eventName, data, callback) {
                socket.emit(eventName, data, function () {
                    $rootScope.$apply(function () {
                        if(callback) {
                            callback.apply(socket, arguments);
                        }
                    });
                })
            },
            // Remove all listeners
            removeAllListeners: function(eventName, callback){
                socket.removeAllListeners(eventName, function(){
                    var args = arguments;
                    $rootScope.$apply(function(){
                        callback.apply(socket, args);
                    });
                });
            },
            // Disconnect socket
            disconnect: function(){
                socket.disconnect();
            },
            // Connect socket
            connect: function(){
                socket.connect();
            }
        };
    }])
app.directive('autogrow', function() {
    return {
        restrict: 'A',
        link: function( scope , element , attributes ) {
            var threshold    = 35,
                minHeight    = element[0].offsetHeight,
                paddingLeft  = element.css('paddingLeft'),
                paddingRight = element.css('paddingRight');

            var $shadow = angular.element('<div></div>').css({
                position:   'absolute',
                top:        -10000,
                left:       -10000,
                width:      element[0].offsetWidth - parseInt(paddingLeft || 0) - parseInt(paddingRight || 0),
                fontSize:   element.css('fontSize'),
                fontFamily: element.css('fontFamily'),
                lineHeight: element.css('lineHeight'),
                resize:     'none'
            });

            angular.element( document.body ).append( $shadow );

            var update = function() {
                var times = function(string, number) {
                    for (var i = 0, r = ''; i < number; i++) {
                        r += string;
                    }
                    return r;
                }

                var val = element.val().replace(/</g, '&lt;')
                    .replace(/>/g, '&gt;')
                    .replace(/&/g, '&amp;')
                    .replace(/\n$/, '<br/>&nbsp;')
                    .replace(/\n/g, '<br/>')
                    .replace(/\s{2,}/g, function( space ) {
                        return times('&nbsp;', space.length - 1) + ' ';
                    });

                $shadow.html( val );

                element.css( 'height' , Math.max( $shadow[0].offsetHeight + threshold , minHeight ) );
            }

            scope.$on('$destroy', function() {
                $shadow.remove();
            });

            element.bind( 'keyup keydown keypress change' , update );
            update();
        }
    }
});
app.factory('Base64', function() {
    var keyStr = 'ABCDEFGHIJKLMNOP' +
            'QRSTUVWXYZabcdef' +
            'ghijklmnopqrstuv' +
            'wxyz0123456789+/' +
            '=';
    return {
        encode: function (input) {
            var output = "";
            var chr1, chr2, chr3 = "";
            var enc1, enc2, enc3, enc4 = "";
            var i = 0;

            do {
                chr1 = input.charCodeAt(i++);
                chr2 = input.charCodeAt(i++);
                chr3 = input.charCodeAt(i++);

                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;

                if (isNaN(chr2)) {
                    enc3 = enc4 = 64;
                } else if (isNaN(chr3)) {
                    enc4 = 64;
                }

                output = output +
                        keyStr.charAt(enc1) +
                        keyStr.charAt(enc2) +
                        keyStr.charAt(enc3) +
                        keyStr.charAt(enc4);
                chr1 = chr2 = chr3 = "";
                enc1 = enc2 = enc3 = enc4 = "";
            } while (i < input.length);

            return output;
        },

        decode: function (input) {
            var output = "";
            var chr1, chr2, chr3 = "";
            var enc1, enc2, enc3, enc4 = "";
            var i = 0;

            // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
            var base64test = /[^A-Za-z0-9\+\/\=]/g;
            if (base64test.exec(input)) {
                alert("There were invalid base64 characters in the input text.\n" +
                        "Valid base64 characters are A-Z, a-z, 0-9, '+', '/',and '='\n" +
                        "Expect errors in decoding.");
            }
            input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");

            do {
                enc1 = keyStr.indexOf(input.charAt(i++));
                enc2 = keyStr.indexOf(input.charAt(i++));
                enc3 = keyStr.indexOf(input.charAt(i++));
                enc4 = keyStr.indexOf(input.charAt(i++));

                chr1 = (enc1 << 2) | (enc2 >> 4);
                chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
                chr3 = ((enc3 & 3) << 6) | enc4;

                output = output + String.fromCharCode(chr1);

                if (enc3 != 64) {
                    output = output + String.fromCharCode(chr2);
                }
                if (enc4 != 64) {
                    output = output + String.fromCharCode(chr3);
                }

                chr1 = chr2 = chr3 = "";
                enc1 = enc2 = enc3 = enc4 = "";

            } while (i < input.length);

            return output;
        }
    };
});
app.directive('bgImg', function(){
    return function(scope, element, attrs){        
        attrs.$observe('bgImg', function(value) {
            element.css({
                'background-image': 'url(' + value +')'
            });
        });
    };
});
app.directive('blockspinner', function() {
	return {
		restrict: 'E',
		template: '<div class="spinner"><div class="bounce1"></div><div class="bounce2"></div><div class="bounce3"></div></div>'
	};
});
app.directive('event', ['$window', '$timeout', function ($window, $timeout) {
    return function(scope, element, attrs) {

        var w = angular.element($window);
    	var b = angular.element('body');
        
        function setMarginLeft(){
            angular.element('.margin-over').css('marginLeft', (b.width() - angular.element('.l-container').width())/2);
            $timeout(function() {
                scope.$apply();
            });
        }        

        w.bind('resize', function() {
            setMarginLeft();
        });

        scope.$watch(function(){
            return b.height();
        }, function(value) {
    		setMarginLeft();
        });

        w.bind('scroll', function() {
            scope.$apply();
        });
    };
}]);
app.factory('Find', function()
{
	var Find = {
		types : [
			["wiki", "type_wikipedia"],
			["twitter/userTimeline", "type_twitterfeed"],
			["twitter/search", "type_twittersearch"],
			["twitter/userInfos", "type_twitteruser"],
			["facebook/infos", "type_facebookinfos"],
			["news", "type_rssfeed"],
			["content", "type_content"],
			["image", "type_image"],
			["link", "type_link"]
		],
		type : function(invar, invert) {
			var outvar = false;
			for(var i in this.types){
			    if(!invert){
			  		if(this.types[i][0]==invar)
			  			outvar=this.types[i][1];
			    }else{
			      if(this.types[i][1]==invar)
			        outvar=this.types[i][0];
			    }
			}
			return outvar;
		}
	}

	return Find;
})
app.directive('focus', function($timeout, $parse) {
  return {
    link: function(scope, element, attrs) {
      var model = $parse(attrs.focus);
      scope.$watch(model, function(value) {
        if(value === true) {
          $timeout(function() {
            element[0].focus(); 
          });
        }
      });
      // element.bind('blur', function() {
      //    scope.$apply(model.assign(scope, false));
      // });
    }
  };
});
app.directive('focusNext', function() {
  return {
    restrict: 'A',
    link: function(scope,elem,attrs) {
      elem.bind('keydown', function(e) {
        var code = e.keyCode || e.which;
        if (code === 13) {
          e.preventDefault();
          var next = elem.next();
          if(next.length > 0)
            next.focus();
          else
            elem.blur();
        }
      });
    }
  }
});
app.filter('fromNow', ['$window', function ($window) {
    return function (dateString) {
        fromNow = $window.moment(new Date(dateString)).fromNow();
        return fromNow.substring(0,1).toUpperCase()+fromNow.substring(1);
    };
}]);
app.filter('htmlToPlaintext', function() {
	return function(text) {
		var tmp = document.createElement("DIV");
		tmp.innerHTML = text;
		return tmp.textContent || tmp.innerText || "";
	}
});
app.factory('HttpInterceptor', function($rootScope, $q, AUTH_EVENTS)
{
  return {
    responseError: function (response) { 
      $rootScope.$broadcast({
        401: AUTH_EVENTS.notAuthenticated,
        403: AUTH_EVENTS.notAuthorized,
        419: AUTH_EVENTS.sessionTimeout,
        440: AUTH_EVENTS.sessionTimeout
      }[response.status], response);
      return $q.reject(response);
    }
  };
})
app.directive('ngEnter', function() {
    return function(scope, element, attrs) {
        element.bind("keydown keypress", function(event) {
            if(event.which === 13) {
                scope.$apply(function(){
                    scope.$eval(attrs.ngEnter, {'event': event});
                });

                event.preventDefault();
            }
        });
    };
})
app.directive('qrcode', ['$window', function($window) {

    var canvas2D = !!$window.CanvasRenderingContext2D,
        levels = {
          'L': 'Low',
          'M': 'Medium',
          'Q': 'Quartile',
          'H': 'High'
        },
        draw = function(context, qr, modules, tile) {
          for (var row = 0; row < modules; row++) {
            for (var col = 0; col < modules; col++) {
              var w = (Math.ceil((col + 1) * tile) - Math.floor(col * tile)),
                  h = (Math.ceil((row + 1) * tile) - Math.floor(row * tile));

              context.fillStyle = qr.isDark(row, col) ? '#000' : '#fff';
              context.fillRect(Math.round(col * tile),
                               Math.round(row * tile), w, h);
            }
          }
        };

    return {
      restrict: 'E',
      template: '<canvas class="qrcode"></canvas>',
      link: function(scope, element, attrs) {
        var domElement = element[0],
            $canvas = element.find('canvas'),
            canvas = $canvas[0],
            context = canvas2D ? canvas.getContext('2d') : null,
            download = 'download' in attrs,
            href = attrs.href,
            link = download || href ? document.createElement('a') : '',
            trim = /^\s+|\s+$/g,
            error,
            version,
            errorCorrectionLevel,
            data,
            size,
            modules,
            tile,
            qr,
            $img,
            setVersion = function(value) {
              version = Math.max(1, Math.min(parseInt(value, 10), 10)) || 4;
            },
            setErrorCorrectionLevel = function(value) {
              errorCorrectionLevel = value in levels ? value : 'M';
            },
            setData = function(value) {
              if (!value) {
                return;
              }

              data = value.replace(trim, '');
              qr = qrcode(version, errorCorrectionLevel);
              qr.addData(data);

              try {
                qr.make();
              } catch(e) {
                error = e.message;
                return;
              }

              error = false;
              modules = qr.getModuleCount();
            },
            setSize = function(value) {
              size = parseInt(value, 10) || modules * 2;
              tile = size / modules;
              canvas.width = canvas.height = size;
            },
            render = function() {
              if (!qr) {
                return;
              }

              if (error) {
                if (link) {
                  link.removeAttribute('download');
                  link.title = '';
                  link.href = '#_';
                }
                if (!canvas2D) {
                  domElement.innerHTML = '<img src width="' + size + '"' +
                                         'height="' + size + '"' +
                                         'class="qrcode">';
                }
                scope.$emit('qrcode:error', error);
                return;
              }

              if (download) {
                domElement.download = 'qrcode.png';
                domElement.title = 'Download QR code';
              }

              if (canvas2D) {
                draw(context, qr, modules, tile);

                if (download) {
                  domElement.href = canvas.toDataURL('image/png');
                  return;
                }
              } else {
                domElement.innerHTML = qr.createImgTag(tile, 0);
                $img = element.find('img');
                $img.addClass('qrcode');

                if (download) {
                  domElement.href = $img[0].src;
                  return;
                }
              }

              if (href) {
                domElement.href = href;
              }
            };

        if (link) {
          link.className = 'qrcode-link';
          $canvas.wrap(link);
          domElement = link;
        }

        setVersion(attrs.version);
        setErrorCorrectionLevel(attrs.errorCorrectionLevel);
        setSize(attrs.size);

        attrs.$observe('version', function(value) {
          if (!value) {
            return;
          }

          setVersion(value);
          setData(data);
          setSize(size);
          render();
        });

        attrs.$observe('errorCorrectionLevel', function(value) {
          if (!value) {
            return;
          }

          setErrorCorrectionLevel(value);
          setData(data);
          setSize(size);
          render();
        });

        attrs.$observe('data', function(value) {
          if (!value) {
            return;
          }

          setData(value);
          setSize(size);
          render();
        });

        attrs.$observe('size', function(value) {
          if (!value) {
            return;
          }

          setSize(value);
          render();
        });

        attrs.$observe('href', function(value) {
          if (!value) {
            return;
          }

          href = value;
          render();
        });
      }
    };
  }]);
app.directive('scrollGlue', ['$parse', function($parse){
    function unboundState(initValue){
        var activated = initValue;
        return {
            getValue: function(){
                return activated;
            },
            setValue: function(value){
                activated = value;
            }
        };
    }

    function oneWayBindingState(getter, scope){
        return {
            getValue: function(){
                return getter(scope);
            },
            setValue: function(){}
        }
    }

    function twoWayBindingState(getter, setter, scope){
        return {
            getValue: function(){
                return getter(scope);
            },
            setValue: function(value){
                if(value !== getter(scope)){
                    scope.$apply(function(){
                        setter(scope, value);
                    });
                }
            }
        };
    }

    function createActivationState(attr, scope){
        if(attr !== ""){
            var getter = $parse(attr);
            if(getter.assign !== undefined){
                return twoWayBindingState(getter, getter.assign, scope);
            } else {
                return oneWayBindingState(getter, scope);
            }
        } else {
            return unboundState(true);
        }
    }

    return {
        priority: 1,
        restrict: 'A',
        link: function(scope, $el, attrs){
            var el = $el[0],
                activationState = createActivationState(attrs.scrollGlue, scope);

            function scrollToBottom(){
                el.scrollTop = el.scrollHeight;
            }

            function onScopeChanges(scope){
                if(activationState.getValue()){
                    scrollToBottom();
                }
            }

            function shouldActivateAutoScroll(){
                // + 1 catches off by one errors in chrome
                return el.scrollTop + el.clientHeight + 1 >= el.scrollHeight;
            }

            function onScroll(){
                activationState.setValue(shouldActivateAutoScroll());
            }

            scope.$watch(onScopeChanges);
            $el.bind('scroll', onScroll);
        }
    };
}]);
app.controller('qCtrl', ['$scope', '$rootScope', '$window', '$location', '$timeout', function($scope, $rootScope, $window, $location, $timeout){

	/**
	 * Search a board
	 */
	$scope.search = function() {

		// Set rootscope q search
		$rootScope.q = $scope.q;

		// If q not empty
		if($rootScope.q.trim().length > 0){
			$scope.isSubmit = true;
			// Launch search
			$timeout(function(){
				$location.path('/search/' + $scope.q, true);
			}, 650);
		}
	}

	/**
	 * On q change
	 * @param  {string} q Search text
	 */
	$scope.qChange = function(q) {

		// Set rootscope q search
		$rootScope.q = q;

		// Change url
		$location.path('/search/' + $scope.q, false);
	}

}]);
app.directive('includeSvg', function(){
    return function(scope, element, attrs){        
        SVGInjector(element);
    };
});
app.directive('videoplayer', function(){
    return {
        restrict : "EA",
        templateUrl : 'templates/template_player.html',
        link : function(scope,element,attrs){

            $(element).find('.close-overlay-help').bind('click',function(){
                player.video.pause();
                player.button.classList.remove('off');
                scope.showHelp=false;
                scope.$apply();
            });

            var player={};

            scope.mp4Src=attrs.mp4Src;
            scope.oggSrc=attrs.oggSrc;
            scope.webmSrc=attrs.webmSrc;
            scope.fallback=attrs.fallback;

            player.video=document.getElementById('video');
            player.button=document.getElementById('button');
            player.pB=document.getElementById('progressBar');

            player.button.classList.add('loading');

            player.playPause = function(e){
                if(e.type=='canplaythrough'){
                    player.video.removeEventListener('canplaythrough',player.playPause,false);
                }
                player.button.classList.remove('loading');
                if(player.video.paused){
                    player.video.play();
                    player.button.classList.add('off');
                }
                else{
                    player.video.pause();
                    player.button.classList.remove('off');
                }
            }

            player.playProgress = function (){
                var self=this;
                var progress=self.currentTime*100/self.duration;
                document.querySelector('.progress').style.width=progress+'%';
            }

            player.setVideoTime = function (e){
                e.stopPropagation();
                player.video.currentTime = e.offsetX*player.video.duration/this.offsetWidth;
            }

            player.video.addEventListener('canplaythrough',function(){
                player.button.classList.remove('loading');
            },false);
            $(element).find(".video_container").bind('click',player.playPause);

            player.video.addEventListener('timeupdate',player.playProgress,false);
            player.pB.addEventListener('click',player.setVideoTime,false);

            player.video.pause();
        }
    }
});
angular
	.module('boViewBoard', [])
	.controller('BoardCtrl', ['$scope', '$rootScope', '$routeParams', '$timeout', '$location', 'Api', 'localStorageService', 'Socket', 'Find', function($scope, $rootScope, $routeParams, $timeout, $location, Api, localStorageService, Socket, Find) {

		// Connect new socket
		Socket.connect();

		// Display full header
		$rootScope.fullHeader = true;

		/**
		 * Get board
		 * @param  {obj} result API result
		 */
        Api.Board.get($routeParams.slug).then(function(result){

        	// Stock the board
        	$scope.board = result.data.data;

        	// Set the page title
        	$rootScope.title = "Boaaard - " + $scope.board.infos.name;

    		// For each blocks
    		(function checkBlocks(i){

    			// If block exist
				if(typeof $scope.board.blocks[i] != "undefined") {

					if($scope.board.blocks[i].type!="image"){

						var input = $scope.board.blocks[i].var;

						if(input){
			                input = input.replace(/#/g, '%23');
			            }

						// Get the content of block
						Api.Block.get($scope.board.blocks[i].type,input,false).then(function(results){
							// En stock it
							$scope.board.blocks[i].content = results.data.data.content;
						});
					}

					// Check the next block
					checkBlocks(i+1);
				}

			})(0);
        });


        // Get the slug in params
        $scope.slug = $routeParams.slug;

        // Input chat username
        $scope.username = null;

        // Get user in localstorage or set to null
        $scope.user = localStorageService.get('user') || null;

        /**
         * Connect to chat
         */
        $scope.connect = function() {

        	// If user find in localstorage
        	if($scope.user)
        		$scope.username = $scope.user; // Set the username

        	// Emit socket for connect user to board chat
            Socket.emit('connectToChat', {
            	'pseudo' : $scope.username,
            	'slug' : $scope.slug
            });
        }

        // If user in localstorage
        if($scope.user) {
        	// Connect it !
        	$scope.connect();
        }

        // Chat messages
        $scope.messages = [];

        /**
         * Get old messages
         * @return {obj}      Old messages
         */
    	Socket.on('oldMessages', function(data) {

    		// For each messages
			for(var i in data.oldmessages){
				// Add messages to chat
				$scope.messages.push(data.oldmessages[i])
			}

			// And display it !
			$scope.$apply();
		});

    	/**
    	 * On user connected to chat
    	 * @return {obj} chat user data
    	 */
		Socket.on('connectedToChat', function(data){

			// Pseudo already use
			$scope.alreadyuse = false;

			// If pseudo already use
			if(data == false){
				$scope.alreadyuse = true;
        		$scope.$apply();
			}
			else{

				// If not local user
				if(!$scope.user) {
	
					// Set user					
	        		$scope.user = $scope.username;

	        		// Add user in localstorage
	            	localStorageService.set('user', $scope.username);
	        	}

	        	// If current user
				if($scope.user == data.pseudo)
					$scope.connected = true; // Allow connection

				// If in same board
				if($scope.slug == data.slug)
					hello(data.pseudo); // Say hello 
        	}
		});

		/**
		 * On new message to chat
		 * @return {obj} new message
		 */
		Socket.on('newMessageToChat', function(data){

			// Add message to chat
			$scope.messages.push(data);
			$scope.$apply(); // Display it

			// If remote connected
			if($scope.remote.connected){

				// Send message to remote
				Socket.emit('sendMessageToRemote', {
					message : data,
					roomid : $scope.roomid
				});
			}
		});

		// New message
		$scope.newMessage = null;

		/**
		 * Add a message to chat
		 * @param {string} message content
		 */
        $scope.addMessage = function(message) {

        	// If message not null
        	if(message.trim().length > 0){

	        	var newMessage = {
	        		message : message,
	        		pseudo : $scope.user,
	        		slug : $scope.slug,
	        		date : new Date().getTime()
	        	}

	        	// Emit new message
	        	Socket.emit('sendMessageToChat', newMessage);

	        	// Reset input
	        	$scope.newMessage = null;
        	}
        }

        /**
         * If remote send message
         * @param  {obj} data message content
         */
        Socket.on('receiveMessageFromRemote', function(data){

        	// Add message to chat
			$scope.addMessage(data.message);
		});

        /**
         * Say hello to others
         * @param  {obj} user name of the user
         */
        function hello(user){

        	// Say hello to chat
        	$scope.messages.push({
        		'message' : user + ' just connect !'
        	});

        	// Display it !
        	$scope.$apply();
        }

        // Block management
         
        $scope.editMode = false;

		/**
		 * Get the template url
		 * @param  {string} type Block type
		 * @return {string} Url of the block
		 */
		$scope.getContentUrl = function(type) {
			var url = 'templates/blocks/'+Find.type(type,false)+'.html';
			return url;
		}

		// Blocks position
		$scope.blockMap = {
			sizeX: 'block.size_x',
			sizeY: 'block.size_y',
			row: 'block.pos_y',
			col: 'block.pos_x'
		};

		/**
		 * Open link in new tab
		 * @param  {string} link Url
		 */
		$scope.openLink = function(link){
			var win = window.open(link, '_blank');
			win.focus();
		}

		// Gridster configuration
		$scope.gridsterOpts = {
			columns: 3,
			margins: [0, 0],
			outerMargin: false,
			minColumns: 1,
			minRows: 2, 
			maxRows: 100,
			defaultSizeX: 1,
			defaultSizeY: 1,
			resizable: {
				enabled: false
			},
			draggable: {
				enabled: false
			}
		};

		/**
		 * On receive control from remote
		 * @param  {obj} data control detail
		 */
		Socket.on('receiveControl', function(data){

			// Control type
			switch(data.control){
				case "playVideo" :
					$scope.board.player.playVideo(); 
					break;
				case "pauseVideo" : 
					$scope.board.player.pauseVideo();
					break;
				case "setVolumeVideo" :
					$scope.board.player.setVolume(data.volume);
					break;
				case "forwardVideo" :
					$scope.board.player.seekTo($scope.board.player.getCurrentTime() + 10);
					break;
				case "backwardVideo" :
					$scope.board.player.seekTo($scope.board.player.getCurrentTime() - 10);
					break;
			}
		});

		// Init remote object
		$scope.remote = {
			connected : false,
			message : {
				content : null,
				url : null
			}
		}

		/**
		 * Add a remote
		 */
		$scope.newRemote = function(){

			// Reset messages content
			$scope.remote.message.content = null;
			$scope.remote.message.url = null;

			// If user connected
			if($scope.user){
				
				console.log('::: New remote :::');

				// Request an id
				Socket.emit('getRemoteId');

				// On respond
				Socket.on('remoteId', function(id){

					var apiKey = 'AIzaSyBXMHqtJBTRTtvtef_iI0EnkwONyP-tRRU';
		            gapi.client.setApiKey(apiKey);

		            // Get an goo.gl url with the id
		            gapi.client.load('urlshortener', 'v1', function() {
		                var request = gapi.client.urlshortener.url.insert({
		                    'resource': {
		                        'longUrl': $location.$$absUrl.split('#')[0] + 'remote/' + id
		                    }
		                });
		                var resp = request.execute(function(resp) {
		                    if (resp.error) {
		                        console.log('Error with url shortener');
		                    } else {
		                    	// Set content message
		                    	$scope.remote.message.content = "Go to :";
		                    	$scope.remote.message.url = resp.id;
		                    	// Display it
		                    	$scope.$apply();
		                    }
		                });
		            });
				});
			}
			else{
				$scope.remote.message.content = "Please, login to chat !";			
			}
		}

		/**
		 * On remote connected
		 * @param  {int} id room id
		 */
		Socket.on('connected', function(id){
			// Set room id
			$scope.roomid = id;
			// Set connected to remote
			$scope.remote.connected = true;
			// Diplay it !
			$scope.$apply();
		});

		/**
		 * On quit
		 */
		$scope.$on('$destroy', function(){
			// Disconnect the socket
			Socket.disconnect();
		});


	}]);
angular
	.module('boViewCreate', [])
	.controller('CreateCtrl', ['$scope', '$rootScope', '$routeParams', '$timeout', 'Api', 'Find', function($scope, $rootScope, $routeParams, $timeout, Api, Find) {

        // Display full header
        $rootScope.fullHeader = true;

        // Board creation
        $scope.manageBoard = false;

        // Set the page title
        $rootScope.title = "Boaaard - Create";

        // Board object
        $scope.board = {
            infos : {
                url : '',
                name : '',
                description : '',
                owner_email : ''
            },
            blocks : {}
        };

        $scope.board.blocks = [];

        // Init some variables
        $scope.startValidate = false;
        $scope.validate = null;
        $scope.saved = false;
        $scope.editMode=true;
        $scope.addBlockOpened = false;

        // Help video
        $scope.showHelp = false;
        $scope.openHelpVideo = function(){
            $scope.showHelp = true;
        }

        // If url params
        if($routeParams.url){
            // Get url in params
            $scope.board.infos.url = 'https://www.youtube.com/watch?v=' + $routeParams.url;
        }
        
        /**
         * Youtube link validation
         */
        $scope.validateYoutube = function() {

            $scope.startValidate = true;
    
            // Get validation from API                
            Api.Video.validate($scope.board.infos.url).then(function(result){

                $scope.startValidate = false;

                // If video OK
                if(result.data.status == true){
                    $scope.validate = true;

                    // Get video thumbnail
                    $scope.thumbnail = result.data.data.items[0].snippet.thumbnails.medium.url;

                    // Sanetize url
                    $scope.board.infos.url = "https://www.youtube.com/watch?v=" + result.data.data.items[0].id;
                    
                    // Next step animation
                    $timeout(function(){
                        $scope.isSubmit = true;
                    }, 1000);
                }
                // Invalid video
                else{

                    // reset animation validation
                    $scope.validate = false;
                    $timeout(function(){
                        $scope.validate = null;
                    }, 1000);
                }
            });
        }

        /**
         * Start board management
         */
        $scope.create = function() {
            $scope.manageBoard = true;
        }

        /**
         * Save board
         */
        $scope.save = function() {

            // Store board in API
            Api.Board.post($scope.board).then(function(result){
                // If ok
                if(result.data.status == true){
                    $scope.saved = true;
                    $scope.slug = result.data.data.infos.slug;
                }
            });
        }

        /**
         * GOAT Easter Egg
         * @param  {int} index Block
         */
        $scope.onChevre = function(index){
            if($scope.board.blocks[index].var=="chevre"){
                $scope.board.blocks[index].var = "http://idata.over-blog.com/3/56/02/16/2010-08/Chevre-yeux.jpg";
                $scope.board.blocks[index].isEdit = false;
            }
        }

        /**
         * Add block to board
         * @param {string} type Type of block
         */
        $scope.addBlock = function(type){

            // If type exist
            type = Find.type(type,true);

            // Close overlay
            $scope.addBlockOpened=false;

            // Push new block
            $scope.board.blocks.push({ type: type, title: "Block title", isEdit: true });
        };

        /**
         * Delete block
         * @param  {int} index Block
         */
        $scope.deleteBlock = function(index){

            // Delete block
            $scope.board.blocks.splice(index, 1);
        }

        /**
         * Save block
         * @param  {int} index Block
         */
        $scope.saveBlock = function(index){

            // If type exist
            var type = Find.type($scope.board.blocks[index].type,false);
            var data = $scope.board.blocks[index].var;

            // If block validation
            if(data){
                // Sanitize
                data = data.replace(/#/g, '%23');
            }

            // Loading content
            $scope.board.blocks[index].isLoading=true;

            // Direct access block
            if(type=="type_content" || type=="type_link" || type=="type_image") {

                // Return block and stop loading
                $scope.board.blocks[index].isEdit = false;
                $scope.board.blocks[index].isLoading=false;

            }
            // Data error
            else if(typeof data == "undefined" || data.length <= 0) {

                ok=false;

                // Stop loading but not return the block
                $scope.board.blocks[index].isLoading=false;

            }
            else {

                // Get block content
                Api.Block.get(type,data,true).then(function(result){

                    var ok = true;

                    if(result.data.data.hasOwnProperty('content')){
                        if(result.data.data.content.hasOwnProperty('statusCode')){
                            if(result.data.data.content.statusCode!=200){
                                ok=false;
                            }
                        }
                    }

                    // Return block and stop content
                    $scope.board.blocks[index].isLoading=false;

                    if(ok){
                        $scope.board.blocks[index].content=result.data.data.content;
                        $scope.board.blocks[index].isEdit = false;
                    }

                });

            }

        }

        /**
         * Focus on input
         */
        $scope.focusInput = function(){
            $(this).focus();
        }

        /**
         * Get block content
         * @param  {string} type Block
         */
        $scope.getContentUrl = function(type) {
            var url = 'templates/blocks/'+Find.type(type,false)+'.html';
            return url;
        }

        // Blocks position
        $scope.blockMap = {
            sizeX: 'block.size_x',
            sizeY: 'block.size_y',
            row: 'block.pos_y',
            col: 'block.pos_x'
        };

        /**
         * Open add block overlay
         */
        $scope.openList = function(){
            $scope.addBlockOpened = true;
        }

        /**
         * Open link in block
         * @param  {string} link URL
         */
        $scope.openLink = function(link){
            var win = window.open(link, '_blank');
            win.focus();
        }

        // Gridster configuration
        $scope.gridsterOpts = {
            columns: 3,
            margins: [0, 0],
            outerMargin: false,
            minColumns: 1,
            minRows: 2, 
            maxRows: 100,
            defaultSizeX: 1,
            defaultSizeY: 1,
            resizable: {
               enabled: true
            },
            draggable: {
               enabled: true
            }
        };

	}]);
angular
	.module('boViewHome', [])
	.controller('HomeCtrl', ['$scope', '$rootScope', '$routeParams', 'Api', function($scope, $rootScope, $routeParams, Api) {

		// Display full header
		$rootScope.fullHeader = false;

		// Reset q (search)
		$rootScope.q = "";

		// Set the page title
		$rootScope.title = "Boaaard";

		// Get list of board
        Api.Board.list().then(function(result){

        	// Stock in scope
        	$scope.boards = result.data.data.slice().reverse().splice(0, 4);
        });
	}]);
angular
	.module('boViewSearch', [])
	.controller('SearchCtrl', ['$scope', '$rootScope', '$routeParams', 'Api', function($scope, $rootScope, $routeParams, Api) {

		// Display full header
		$rootScope.fullHeader = true;

		// Send q param url to rootScope
		$rootScope.q = $routeParams.q;

		// Set the page title
		$rootScope.title = "Boaaard - " + $rootScope.q;

		// Get board list
		Api.Board.list().then(function(result){
			// Stock in scope
        	$scope.boards = result.data.data;
        });
	}]);